# Test fuzzing rich sigs. We could assume go-fuzz and go-fuzz-build binaries are in the path,
# but we start these tests doing 'go get' on github.com/dvyukov/go-fuzz/... because we need
# the go-fuzz-dep source code to be findable by go-fuzz-build (when it invokes 'go list').
# Reminder: the tests here can be run by themselves from the fzgo directory via:
#    go test -run=TestScripts/fuzzing_rich_signatures .

# Exit early if -short was specified.
[short] skip 'skipping building instrumented binary because -short was specified'

# get our dependencies
go get -v -u github.com/thepudds/fzgo/...
go get -v -u github.com/google/gofuzz
go get -v -u golang.org/x/tools/cmd/goimports

# Verify goimports binary seems to exist in our test environment
exists $WORK/gopath/bin/goimports$exe

# Get go-fuzz (go-fuzz-dep needed by go-fuzz-build).
go get -v -u github.com/dvyukov/go-fuzz/...
go install github.com/dvyukov/go-fuzz/...

# Verify the go-fuzz binaries seem to exist in our test environment
exists $WORK/gopath/bin/go-fuzz$exe
exists $WORK/gopath/bin/go-fuzz-build$exe

# First fuzz test: no fzgo cache, so we build the instrumented binary from scratch.
# This also creates our corpus directory in the default location.
fzgo test -fuzz=FuzzWithBasicTypes example.com/richsignatures -fuzztime=5s
stdout 'building instrumented binary for pkgname.FuzzWithBasicTypes'
stderr 'workers: \d+, corpus: '
exists $WORK/gopath/pkg/fuzz/corpus/example.com/richsignatures/FuzzWithBasicTypes/corpus

# Second fuzz test: now we use the fzgo cache.
# We also specify -parallel=1 to reduce CPU usage for our remaining tests.
fzgo test -fuzz=FuzzWithBasicTypes example.com/richsignatures -parallel=1 -fuzztime=5s
stdout 'fzgo: using cached instrumented binary for pkgname.FuzzWithBasicTypes'
stderr 'workers: \d+, corpus: '

# Flag -fuzzdir controls where the corpus goes (which could be in a different repo). 
# This invocation still uses the cache, as do all subsequent invocations in this script.
fzgo test -fuzz=FuzzWithBasicTypes example.com/richsignatures -parallel=1 -fuzztime=5s -fuzzdir=$WORK/myfuzzdir
stdout 'fzgo: using cached instrumented binary for pkgname.FuzzWithBasicTypes'
stderr 'workers: \d+, corpus: '
exists $WORK/myfuzzdir/example.com/richsignatures/FuzzWithBasicTypes/corpus

# Uncomment this next line if you don't want to rely on goimports
# [!exec:goimports] stop 'skipping remaining step that currently relies on goimports being in the path'

# Make sure goimports can be executed. 
! exec goimports -h
stderr 'goimports'

# Check rich signature from stdlib (uses regexp)
# This currently relies on goimports being in the path.
fzgo test -fuzz=FuzzWithStdlibType example.com/richsignatures -parallel=1 -fuzztime=5s
stdout 'building instrumented binary for pkgname.FuzzWithStdlibType'
stderr 'workers: \d+, corpus: '
exists $WORK/gopath/pkg/fuzz/corpus/example.com/richsignatures/FuzzWithStdlibType/corpus

# Check we can get a crasher relatively quickly by finding a 64 bit int via a rich signature, which
# should imply go-fuzz literal injection is working end-to-end with fzgo's rich signatures.
fzgo test -fuzz=FuzzHardToGuessNumber example.com/richsignatures -parallel=1 -fuzztime=10s
stdout 'building instrumented binary for pkgname.FuzzHardToGuessNumber'
stderr 'workers: \d+, corpus: .* crashers: [^0]'
exists $WORK/gopath/pkg/fuzz/corpus/example.com/richsignatures/FuzzHardToGuessNumber/corpus

# NOTE: currently this is cloned from examples dir in fzgo repo. (Probably good to have locally here?)

-- gopath/src/example.com/richsignatures/richsignatures.go --
package pkgname

import (
	"regexp"

	"github.com/thepudds/fzgo/fuzz"
)

// FuzzWithBasicTypes is a fuzzing function written by a user
// that has a rich signature. All parameters are basic types,
// but is uses stdlib types within (regexp).
// We can fuzz it automatically, even though it doesn't match the standard []data
// signature. This is just a test -- the fuzzing itself is not of interest.
func FuzzWithBasicTypes(re string, input []byte, posix bool) (bool, error) {

	var r *regexp.Regexp
	var err error
	if posix {
		r, err = regexp.CompilePOSIX(re)
	} else {
		r, err = regexp.Compile(re)
	}
	if err != nil {
		return false, err
	}

	return r.Match(input), nil
}

// FuzzWithStdlibType is a test function using a combination of basic types
// and also one from the stdlib (regexp).
func FuzzWithStdlibType(something, another string, allow bool, re *regexp.Regexp) {
	regexp.MatchString(something, another)
}

// FuzzWithFzgoFunc uses a non-stdlib type
func FuzzWithFzgoFunc(f fuzz.Func) string {
	return f.String()
}

// ExampleType is defined in the same package as the fuzz target that uses it (next func below).
type ExampleType int

// FuzzWithTargetType shows a type defined in the same file as the fuzz function.
func FuzzWithTargetType(e ExampleType) {

}

// FuzzHardToGuessNumber is a sanity check that go-fuzz literal injection seems to be working end-to-end.
// This is typically found within a few seconds when properly hooked up.
func FuzzHardToGuessNumber(guessMe int64) {

	if guessMe == 0x123456789 {
		panic("bingo")
	}
}
